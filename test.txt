std::vector<cv::Point2f> new_img_points;
std::vector<cv::Point2f> new_world_points;
std::vector<cv::Point2f> img_points;
std::vector<cv::Point2f> world_points;

void choose_points_in_board(cv::Mat &img, cv::Mat &img_new,
                            cv::Mat &img_new_bk);
void OnButtonClick(int event, int x, int y, int flags, void *userdata);
void DrawCorners(const cv::Mat &src, cv::Mat &dst);
void ManuallySetPoint(const cv::Mat &img_bk, cv::Mat &img_click, cv::Mat &img);
void ManuallyAdjustCorner(const cv::Mat &img_bk, cv::Mat &img);
void help();

void choose_points_in_board(cv::Mat &img, cv::Mat &img_new,
                            cv::Mat &img_new_bk) {
  cv::Mat img_ = img.clone();
  cv::cvtColor(img, img, CV_GRAY2BGR);
  cv::imwrite("origin_image.png", img);
  img = img.rowRange(image_row_offset, img.rows);
  cv::Mat img_click = img.clone();
  cv::Mat img_bk = img.clone();

  // set point and adjust
  std::cout << "Whether to manually select points(y/n): ";
  char is_manually;
  std::cin >> is_manually;
  if (is_manually == 'y' || is_manually == 'Y') {
    ManuallySetPoint(img_bk, img_click, img);
  }

  std::cout << "Whether to manually adjust the corrected corners?(y/n): ";
  std::cin >> is_manually;
  while (is_manually == 'y' || is_manually == 'Y') {
    ManuallyAdjustCorner(img_bk, img);
    std::cout
        << "Whether to manually adjust the corrected corners again?(y/n): ";
    std::cin >> is_manually;
  }
  img_new = img;
  img_new_bk = img_bk;
}

void OnButtonClick(int event, int x, int y, int flags, void *userdata) {
  cv::Mat img = *((cv::Mat *)userdata);
  float u = 0;
  float v = 0;
  float square_x = 0;
  float square_y = 0;

  if (event == cv::EVENT_LBUTTONDOWN) {
    u = 1.0 * x;
    v = 1.0 * y;
    cv::Point2f img_point = cv::Point2f(u, v);
    char point_info[100];
    sprintf(point_info, " u : %.2f v : %.2f", u, v);
    cv::circle(img, img_point, 2, cv::Scalar(255, 0, 0), 2);
    cv::putText(img, std::string(point_info), img_point,
                cv::FONT_HERSHEY_DUPLEX, 0.6, cv::Scalar(0, 0, 255), 0.6, 8);
    cv::imshow("Image", img);
    cv::waitKey(10);
    std::cout << "please input world square index (x) : " << std::endl;
    std::cin >> square_x;
    std::cout << "please input world square index (y) : " << std::endl;
    std::cin >> square_y;
    cv::Point2f world_point = cv::Point2f(1.0 * square_x, 1.0 * square_y);
    std::cout << " x : " << world_point.x << std::endl;
    std::cout << " y : " << world_point.y << std::endl;
    new_img_points.push_back(img_point);
    new_world_points.push_back(world_point);
    sprintf(point_info, "x:%.2f y:%.2f", world_point.x, world_point.y);
    cv::putText(img, std::string(point_info), img_point + cv::Point2f(0, 25),
                cv::FONT_HERSHEY_DUPLEX, 0.6, cv::Scalar(0, 0, 255), 0.6, 4);
    cv::imshow("Image", img);
    cv::waitKey(10);
  }
}

void DrawCorners(const cv::Mat &src, cv::Mat &dst) {
  // draw subpixel chessborad corners
  dst = src.clone();
  for (size_t i = 0; i < img_points.size(); i++) {
    cv::Point2f im_point = img_points[i];
    cv::Point2f w_point = world_points[i];
    cv::circle(dst, im_point, 2, cv::Scalar(255, 0, 0), 2);
    char point_info[100];
    sprintf(point_info, "u:%.2f v:%.2f", im_point.x, im_point.y);
    std::cout << im_point.x << ", " << im_point.y << std::endl;
    cv::putText(dst, std::string(point_info), im_point, cv::FONT_HERSHEY_DUPLEX,
                0.6, cv::Scalar(0, 0, 255), 0.6, 4);
    sprintf(point_info, "x:%.2f y:%.2f", w_point.x, w_point.y);
    std::cout << w_point.x << ", " << w_point.y << std::endl;
    cv::putText(dst, std::string(point_info), im_point + cv::Point2f(0, 25),
                cv::FONT_HERSHEY_DUPLEX, 0.6, cv::Scalar(0, 0, 255), 0.6, 4);

    sprintf(point_info, "corner index: %lu", i);
    cv::putText(dst, std::string(point_info), im_point - cv::Point2f(0, 25),
                cv::FONT_HERSHEY_DUPLEX, 0.6, cv::Scalar(0, 255, 0), 0.6, 4);
  }
  cv::imshow("precise corners ", dst);
  cv::waitKey(1);
}

void Help() {
  std::cout << "Enter 'a' to add corners." << std::endl;
  std::cout << "Enter 'd' to delete extra corners." << std::endl;
  std::cout << "    then, input the index of corner which you want to delete."
            << std::endl;
  std::cout << "Enter 'i' to adjust the corner image coord." << std::endl;
  std::cout << "    then, input the offset of corner which you want to adjust."
            << std::endl;
  std::cout
      << "    the right of image is in the positive direction of the x-axis."
      << std::endl;
  std::cout
      << "    the top is of image in the positive direction of the y-axis."
      << std::endl;
  std::cout << "Enter 'w' to adjust the corner world coord." << std::endl;
  std::cout << "    then, input the offset of corner which you want to adjust."
            << std::endl;
  std::cout
      << "    the right of car is in the positive direction of the x-axis."
      << std::endl;
  std::cout
      << "    the front of car is in the positive direction of the y-axis."
      << std::endl;
}

void ManuallySetPoint(const cv::Mat &img_bk, cv::Mat &img_click, cv::Mat &img) {

  cv::namedWindow("Image", cv::WINDOW_AUTOSIZE);
  cv::setMouseCallback("Image", OnButtonClick, &img_click);
  while (true) {
    cv::imshow("Image", img_click);
    int keycode = cv::waitKey(10);
    if (keycode == 27)
      break;
  }
  cv::destroyWindow("Image");

  std::cout << " starting find subpixel corners " << std::endl;
  cv::cvtColor(img, img, CV_BGR2GRAY);
  cv::cornerSubPix(
      img, new_img_points, cv::Size(7, 7), cv::Size(-1, -1),
      cv::TermCriteria(cv::TermCriteria::EPS | cv::TermCriteria::MAX_ITER, 30,
                       0.1));
  for (int i = 0; i < new_img_points.size(); ++i) {
    img_points.push_back(new_img_points[i]);
    world_points.push_back(new_world_points[i]);
  }
  new_img_points.clear();
  new_world_points.clear();
  cv::cvtColor(img, img, CV_GRAY2BGR);

  DrawCorners(img_bk, img);
}

void ManuallyAdjustCorner(const cv::Mat &img_bk, cv::Mat &img) {
  Help();
  int square_x = 0;
  int square_y = 0;
  std::cout << "please choose what to do('a' or 'd' or 'i' or 'w'): ";
  char which_operation;
  std::cin >> which_operation;
  if (which_operation == 'a' || which_operation == 'A') {
    ManuallySetPoint(img_bk, img, img);
  } else if (which_operation == 'd' || which_operation == 'D') {
    std::cout << "please input which corner you want to delete: ";
    int d_index;
    std::cin >> d_index;
    if (d_index >= 0 && d_index < img_points.size()) {
      img_points.erase(img_points.begin() + d_index);
      world_points.erase(world_points.begin() + d_index);
    }
  } else if (which_operation == 'i' || which_operation == 'I') {
    std::cout << "please input which corner you want to adjust: ";
    int d_index;
    std::cin >> d_index;
    if (d_index >= 0 && d_index < img_points.size()) {
      std::cout << "please input the offset if x-axis: " << std::endl;
      std::cin >> square_x;
      std::cout << "please input the offset if y-axis: " << std::endl;
      std::cin >> square_y;
      img_points[d_index] += cv::Point2f(square_x, square_y);
    }
  } else if (which_operation == 'w' || which_operation == 'W') {
    std::cout << "please input which corner you want to adjust: ";
    int d_index;
    std::cin >> d_index;
    if (d_index >= 0 && d_index < img_points.size()) {
      std::cout << "please input the offset if x-axis: " << std::endl;
      std::cin >> square_x;
      std::cout << "please input the offset if y-axis: " << std::endl;
      std::cin >> square_y;
      world_points[d_index] += cv::Point2f(square_x, square_y);
    }
  }
  DrawCorners(img_bk, img);
}
